"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const apollo_link_1 = require("apollo-link");
const apollo_link_http_1 = require("apollo-link-http");
const graphql_1 = require("graphql");
const https_1 = require("https");
const apollo_env_1 = require("apollo-env");
const url_1 = require("url");
class IntrospectionSchemaProvider {
    constructor(config) {
        this.config = config;
    }
    async resolveSchema() {
        if (this.schema)
            return this.schema;
        const { skipSSLValidation, url, headers } = this.config;
        let options = { uri: url, fetch: apollo_env_1.fetch };
        if (skipSSLValidation) {
            const urlObject = new url_1.URL(url);
            const host = urlObject.host;
            const port = +urlObject.port || 443;
            const agentOptions = {
                host: host,
                port: port,
                rejectUnauthorized: false
            };
            const agent = new https_1.Agent(agentOptions);
            options.fetchOptions = { agent: agent };
        }
        const { data, errors } = (await apollo_link_1.toPromise(apollo_link_1.execute(apollo_link_http_1.createHttpLink(options), {
            query: graphql_1.parse(graphql_1.getIntrospectionQuery()),
            context: { headers }
        })));
        if (errors) {
            throw new Error(errors.map(({ message }) => message).join("\n"));
        }
        if (!data) {
            throw new Error("No data received from server introspection.");
        }
        this.schema = graphql_1.buildClientSchema(data);
        return this.schema;
    }
    onSchemaChange(_handler) {
        throw new Error("Polling of endpoint not implemented yet");
        return () => { };
    }
}
exports.IntrospectionSchemaProvider = IntrospectionSchemaProvider;
//# sourceMappingURL=introspection.js.map