"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const cosmiconfig = require("cosmiconfig");
const cosmiconfig_typescript_loader_1 = require("@endemolshinegroup/cosmiconfig-typescript-loader");
const path_1 = require("path");
const fs_1 = require("fs");
const fp_1 = require("lodash/fp");
exports.DefaultEngineStatsWindow = {
    to: -0,
    from: -86400
};
exports.DefaultEngineConfig = {
    endpoint: "https://engine-graphql.apollographql.com/api/graphql",
    frontend: "https://engine.apollographql.com"
};
exports.DefaultConfigBase = {
    includes: ["src/**/*.{ts,tsx,js,jsx,graphql}"],
    excludes: ["**/node_modules", "**/__tests__"]
};
exports.DefaultClientConfig = Object.assign({}, exports.DefaultConfigBase, { tagName: "gql", clientOnlyDirectives: ["connection", "type"], clientSchemaDirectives: ["client", "rest"], addTypename: true, statsWindow: exports.DefaultEngineStatsWindow });
exports.DefaultServiceConfig = Object.assign({}, exports.DefaultConfigBase, { endpoint: {
        url: "http://localhost:4000/graphql"
    } });
const MODULE_NAME = "apollo";
const defaultSearchPlaces = [
    "package.json",
    `${MODULE_NAME}.config.js`,
    `${MODULE_NAME}.config.ts`
];
const getSearchPlaces = (configFile) => [
    ...(configFile ? [configFile] : []),
    ...defaultSearchPlaces
];
const loaders = {
    ".json": cosmiconfig.loadJson,
    ".js": cosmiconfig.loadJs,
    ".ts": {
        async: cosmiconfig_typescript_loader_1.default
    }
};
exports.projectsFromConfig = (config) => {
    const configs = [];
    const { client, service } = config, rest = __rest(config, ["client", "service"]);
    if (client)
        configs.push(new ClientConfig(config));
    if (service)
        configs.push(new ServiceConfig(config));
    return configs;
};
exports.parseServiceSpecificer = (specifier) => {
    const [id, tag] = specifier.split("@").map(x => x.trim());
    return [id, tag];
};
exports.getServiceName = (config) => {
    if (config.service)
        return config.service.name;
    if (config.client) {
        if (typeof config.client.service === "string") {
            return exports.parseServiceSpecificer(config.client
                .service)[0];
        }
        return config.client.service && config.client.service.name;
    }
    else {
        return undefined;
    }
};
class ApolloConfig {
    constructor(rawConfig) {
        this.rawConfig = rawConfig;
        this.isService = !!rawConfig.service;
        this.isClient = !!rawConfig.client;
        this.engine = rawConfig.engine;
        this.name = exports.getServiceName(rawConfig);
        this.client = rawConfig.client;
        this.service = rawConfig.service;
    }
    get projects() {
        return exports.projectsFromConfig(this.rawConfig);
    }
    set tag(tag) {
        this._tag = tag;
    }
    get tag() {
        if (this._tag)
            return this._tag;
        let tag = "current";
        if (this.client && typeof this.client.service === "string") {
            const specifierTag = exports.parseServiceSpecificer(this.client
                .service)[1];
            if (specifierTag)
                tag = specifierTag;
        }
        return tag;
    }
    setDefaults({ client, engine, service }) {
        const config = fp_1.merge(this.rawConfig, { client, engine, service });
        this.rawConfig = config;
        this.client = config.client;
        this.service = config.service;
        if (engine)
            this.engine = config.engine;
    }
}
exports.ApolloConfig = ApolloConfig;
class ClientConfig extends ApolloConfig {
}
exports.ClientConfig = ClientConfig;
class ServiceConfig extends ApolloConfig {
}
exports.ServiceConfig = ServiceConfig;
function isClientConfig(config) {
    return config.isClient;
}
exports.isClientConfig = isClientConfig;
function isLocalServiceConfig(config) {
    return !!config.localSchemaFile;
}
exports.isLocalServiceConfig = isLocalServiceConfig;
function isServiceConfig(config) {
    return config.isService;
}
exports.isServiceConfig = isServiceConfig;
exports.loadConfig = async ({ configPath, name, type }) => {
    const explorer = cosmiconfig(MODULE_NAME, {
        searchPlaces: getSearchPlaces(configPath),
        loaders
    });
    let loadedConfig = (await explorer.search(configPath));
    if (!loadedConfig) {
        loadedConfig = {
            isEmpty: false,
            filepath: configPath || process.cwd(),
            config: type === "client"
                ? {
                    client: Object.assign({ service: name }, exports.DefaultConfigBase)
                }
                : { service: Object.assign({ name: name }, exports.DefaultConfigBase) }
        };
    }
    let { config, filepath, isEmpty } = loadedConfig;
    const dotEnvPath = path_1.resolve(path_1.parse(filepath).dir, ".env");
    if (fs_1.existsSync(dotEnvPath)) {
        const env = require("dotenv").parse(fs_1.readFileSync(dotEnvPath));
        if (env["ENGINE_API_KEY"]) {
            config = fp_1.merge({ engine: { apiKey: env["ENGINE_API_KEY"] } }, config);
        }
    }
    if (isEmpty) {
        throw new Error(`Apollo config found at ${filepath} is empty. Please add either a client or service config`);
    }
    if (config.client)
        config = fp_1.merge({ client: exports.DefaultClientConfig }, config);
    if (config.service)
        config = fp_1.merge({ service: exports.DefaultServiceConfig }, config);
    config = fp_1.merge({ engine: exports.DefaultEngineConfig }, config);
    return { config: new ApolloConfig(config), filepath, isEmpty };
};
//# sourceMappingURL=config.js.map