"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const Listr = require("listr");
const path_1 = require("path");
const apollo_language_server_1 = require("apollo-language-server");
const OclifLoadingHandler_1 = require("./OclifLoadingHandler");
const { version, referenceID } = require("../package.json");
const headersArrayToObject = (arr) => {
    if (!arr)
        return;
    return arr
        .map(val => JSON.parse(val))
        .reduce((pre, next) => (Object.assign({}, pre, next)), {});
};
const getServiceFromKey = (key) => {
    const [type, service] = key.split(":");
    if (type === "service")
        return service;
    return;
};
class ProjectCommand extends command_1.default {
    constructor() {
        super(...arguments);
        this.tasks = [];
        this.type = "service";
    }
    async init() {
        const { flags, args } = this.parse(this.constructor);
        this.ctx = { flags, args };
        const { config, filepath } = await this.createConfig(flags);
        this.createService(config, filepath, flags);
        (this.ctx.config = config),
            this.tasks.push({
                title: "Loading Apollo Project",
                task: async (ctx) => {
                    await this.project.whenReady;
                    ctx = Object.assign({}, ctx, this.ctx);
                }
            });
    }
    async createConfig(flags) {
        let service;
        if (process.env.ENGINE_API_KEY)
            service = getServiceFromKey(process.env.ENGINE_API_KEY);
        if (flags.key)
            service = getServiceFromKey(flags.key);
        const loadedConfig = await apollo_language_server_1.loadConfig({
            configPath: flags.config,
            name: service,
            type: this.type
        });
        const { config, filepath, isEmpty } = loadedConfig;
        if (flags.tag)
            config.tag = flags.tag;
        config.setDefaults({
            engine: {
                apiKey: flags.key,
                endpoint: flags.engine,
                frontend: flags.frontend
            }
        });
        if (flags.endpoint) {
            config.setDefaults({
                service: {
                    endpoint: {
                        url: flags.endpoint,
                        headers: headersArrayToObject(flags.header)
                    }
                }
            });
        }
        if (flags.localSchemaFile) {
            if (apollo_language_server_1.isClientConfig(config)) {
                config.setDefaults({
                    client: {
                        service: {
                            localSchemaFile: flags.localSchemaFile
                        }
                    }
                });
            }
            else if (apollo_language_server_1.isServiceConfig(config)) {
                config.setDefaults({
                    service: {
                        localSchemaFile: flags.localSchemaFile
                    }
                });
            }
        }
        if (this.configMap) {
            const defaults = this.configMap(flags);
            config.setDefaults(defaults);
        }
        return { config, filepath, isEmpty };
    }
    createService(config, filepath, flags) {
        const loadingHandler = new OclifLoadingHandler_1.OclifLoadingHandler(this);
        const rootURI = `file://${path_1.parse(filepath).dir}`;
        const clientIdentity = {
            name: "Apollo CLI",
            version,
            referenceID
        };
        if (apollo_language_server_1.isServiceConfig(config)) {
            this.project = new apollo_language_server_1.GraphQLServiceProject({
                config,
                loadingHandler,
                rootURI,
                clientIdentity
            });
        }
        else if (apollo_language_server_1.isClientConfig(config)) {
            this.project = new apollo_language_server_1.GraphQLClientProject({
                config,
                loadingHandler,
                rootURI,
                clientIdentity
            });
        }
        this.ctx.project = this.project;
    }
    async runTasks(generateTasks) {
        const tasks = await generateTasks(this.ctx);
        return new Listr([...this.tasks, ...tasks]).run();
    }
    async catch(err) {
        this.error(err);
    }
    async finally(err) {
    }
}
ProjectCommand.flags = {
    config: command_1.flags.string({
        char: "c",
        description: "Path to your Apollo config file"
    }),
    header: command_1.flags.string({
        multiple: true,
        parse: header => {
            const [key, value] = header.split(":");
            return JSON.stringify({ [key.trim()]: value.trim() });
        },
        description: "Additional headers to send to server for introspectionQuery"
    }),
    endpoint: command_1.flags.string({
        description: "The url of your service"
    }),
    key: command_1.flags.string({
        description: "The API key for the Apollo Engine service",
        default: () => process.env.ENGINE_API_KEY
    }),
    engine: command_1.flags.string({
        description: "Reporting URL for a custom Apollo Engine deployment",
        hidden: true
    }),
    frontend: command_1.flags.string({
        description: "URL for a custom Apollo Engine frontend",
        hidden: true
    })
};
exports.ProjectCommand = ProjectCommand;
class ClientCommand extends ProjectCommand {
    constructor(argv, config) {
        super(argv, config);
        this.type = "client";
        this.configMap = (flags) => {
            const config = {
                client: {
                    name: flags.clientName,
                    referenceID: flags.clientReferenceId,
                    version: flags.clientVersion
                }
            };
            if (flags.endpoint) {
                config.client.service = {
                    url: flags.endpoint,
                    headers: headersArrayToObject(flags.headers)
                };
            }
            return config;
        };
    }
}
ClientCommand.flags = Object.assign({}, ProjectCommand.flags, { clientReferenceId: command_1.flags.string({
        description: "Reference id for the client which will match ids from client traces, will use clientName if not provided"
    }), clientName: command_1.flags.string({
        description: "Name of the client that the queries will be attached to"
    }), clientVersion: command_1.flags.string({
        description: "The version of the client that the queries will be attached to"
    }), tag: command_1.flags.string({
        char: "t",
        description: "The published service tag for this client",
        default: "current"
    }) });
exports.ClientCommand = ClientCommand;
//# sourceMappingURL=Command.js.map